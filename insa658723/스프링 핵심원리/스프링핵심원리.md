- **섹션1**
    
    JPA: orm, 자바객체를 db에 편하게 저장하고 빼는 역할.
    
    JPA 구현체: 하이버네이트, Eclipelink…
    
    JPA 구현체들의 표준 인터페이스: JPA
    
    스프링이란?
    
    스프링 데이터: CRUD를 편하게 사용하도록 도와줌.
    
    스프링 프레임워크 → 스프링부트를 통해서 사용함.
    
    스프링부트
    
    - 웹서버를 내장
    - stater 종속성 제공
    
    스프링부트는 기능을 제공하는 틀같은 것. 기본적으로는 스프링 프레임워크를 사용해야함.
    
    스프링은 자바 언어 기반의 프레임워크
    
    스프링은 객체지향언어의 강력한 특징을 살리는 프레임워크
    
    즉, 좋은 객체지향 어플리케이션을 개발할 수 있게 도와줌.
    
     좋은 객체 지향 프로그래밍이란?
    
    - 객체지향 프로그래밍은 프로그램을 명령어의 목록으로 보는 것이 아니라 각 객체들의 모임으로 파악하는 것이다. 객체끼리 메세지를 주고받는다. 프로그램을 유연하게 만든다.
        
        유연하고 변경이 용이? ⇒ 블럭을 조립하고 부품을 갈아 끼우듯이. **다형성**
        
    - **역할과 구현의 분리.**
        - 클라이언트는 대상의 역할(인터페이스)만 알면된다.
        - 구현대상의 내부나 자체에 영향을 받지 않는다.
        - 역할 = 인터페이스, 구현 = 클래스, 객체
        - 반면에 인터페이스가 변하면, 클라이언트와 서버 모두에게 큰 변화가 생긴다.
        
        **⇒ 때문에 인터페이스를 안정적으로 잘 설계하는 것이 중요하다!!**
        
    - 수많은 객체 클라이언트와 객체 서버는 협력 관계를 가진다.
    
    **의존관계는 서로를 안다는 뜻. ⇒ ?**
    
    다형성의 본질
    
    - 인터페이스를 구현한 객체 인스턴스를 **실행시점**에 유연하게 변경할 수 있다.
    - 다형성의 본질에서 **객체사이의 협력관계**가 중요하다.
    - 클라이언트를 변경하지 않고 서버의 구현기능을 유연하게 변경할 수 있다. ex) MemberService(클라이언트)와 Memory, Jdbc MemberRepository(서버)
    
    스프링과 객체 지향
    
    - 다형성이 제일 중요.
    - 스프링은 다형성을 극대화해준다. 즉, 스프링을 사용하면 부품을 갈아끼워 조립하듯 구현을 편하게 해준다.
    
    SOLID
    
    - SRP(단일 책임 원칙)
        - 한 클래스는 하나의 책임만 가져야 한다.
        - 책임의 기준은 모호하다.
        - 변경이 있을 때 다른 부분의 파급효과가 적으면 단일 책임원칙을 잘 따른 것이다.(변경이 있을 때 한 클래스나 단일부분만 수정을 함.)
    - OCP(개방 폐쇄 원칙) → 제일 중요
        - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야함.
        - 기존 코드를 바꾸는 것이 아니라 새로운 클래스를 추가에서 확장을 함.
        - 하지만 클라이언트에서 코드를 변경해야 구현 객체를 변경해야하는 문제가 생김. 즉, OCP가 깨짐.
        - 때문에 객체를 생성하고 관계를 맺어주는 별도의 무언가가 있어야함 → 스프링 컨테이너가 해줌.
    - LSP(리스코프 치환 원칙)
        - 다형성에서 하위클래스는 인터페이스 규약을 다 지켜야한다.
    - ISP(인터페이스 분리 원칙)
        - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
        - 즉 인터페이스를 더 작게 분리하는 것이다.
        - 자동차를 운전, 정비 인터페이스로, 사용자를 운전자, 정비사 인터페이스로 분리시킨다.
        - 인테페이스가 명확해지고, 대체 가능성이 높아짐.
    - DIP(의존관계 역전 원칙)
        - 추상화에 의존, 구체화에 의존 X
        - 클라이언트 코드가, 구현 클래스에 의존하지 말고 인터페이스에 의존해야한다.
        - 즉, 역할에 의존하라는 뜻.
        - 의존이라는 것은 그 코드에 대해서 알기만 하면 의존한다고 한다.
    
    정리
    
    - 객체지향의 핵심은 다형성.
    - 다형성만으로는 OCP, DIP를 못지킴.
    - 즉, 부품을 갈아 끼우는 것이 어렵고, 구현 객체를 변경할때 클라이언트 코드도 변경해야한다.
    
    객체 지향 설계와 스프링
    
    - 스프링은 아래 기술로 다형성 + OCP, DIP를 가능하게 함.
        - DI: 의존관계, 의존성 주입
        - DI 컨테이너 제공
    - 클라이언트 코드의 변경 없이 기능을 확장 할 수 있음.
    - 스프링 컨테이너가 이 기능들을 도와줌.
    - 이상적으로는 인터페이스를 완벽하게 해야한다.
        - 하지만 코드가 추상화가 되면 비용이 발생한다.
        - 기능을 확장할 가능성이 없으면 우선 구체 클래스를 사용하고, 향후 인터페이스를 도입해도 된다.
- **섹션2**
    
    **프로젝트 생성**
    
    gradle을 수정할 경우 우측 상단의 코끼리모양 버튼을 눌러야한다.
    
    Tip: Preference → gradle → Build and run using, Run tests using을 IntelliJ로 변경.
    
    Why? → gradle을 통하지 않고 바로 인텔리제이를 통해서 실행하므로 빠르다.
    
    **비즈니스 요구사항과 설계**
    
    - 회원 데이터와 할인 정책은 미확정이다. 이 부분을 역할과 구현의 분리를 통해 언제든지 부품을 깔아끼우듯이 바꿀 수 있도록 설계하면 된다.
    
    **회원도메인 설계**
    
    - 클라이언트 → 회원서비스 → 회원저장소(인터페이스) ← 구현체는 여러개로 나뉜다.
    - 우선 메모리 구현체로 만든다.(재실행하면 메모리가 다 날라가기 때문에 단순히 개발용으로 사용한다.) 그리고 이후에 다른 구현체를 만들어서 갈아 끼우면 된다.
    - MemberService를 Interface로 만들고, 구현체를 만든다.(MemberServiceImpl)
    - 회원 객체 다이어그램은 실제 서버가 떠서 그 안에 실제 사용되는 객체끼리 바라보고 있는 관계를 보여준다.
    
    **회원도메인 개발**
    
    - enum으로 회원등급
    - Entity 생성. 엔티티란?? →
    - 구현체가 하나만 있을 경우 구현체명 뒤에 Impl을 붙이는 관례가 있다.
    - MemberService 구현체는 MemerRepositoy 저장소가 필요하다. 때문에 인터페이스를 사용하여 Repositoy 구현체를 생성한다.
        
        ```java
        public class MemberServiceImpl implements MemberService {
        private final MemberRepository memberRepository = 
        					new MemoryMemberRepository();
        					}
        ```
        
    - Test를 실행할 때는 annotation @Test를 붙이고, given, when, then을 사용한다.
    
    하지만 문제점이 발생한다.
    
    ```java
    public class MemberServiceImpl implements MemberService{
    
      private final MemberRepository memberRepository = 
    						  new MemoryMemberRepository();
    ```
    
    여기서 MemberServiceImpl는 MemberRepository는 인터페이스를 의존하지만, 할당하는 부분MemoryMemberRepository는 구현체를 의존한다. 즉, 추상화에도 의존하고 구체화에도 의존한다.
    
    **주문과 할인 도메인 설계, 개발**
    
    - 역할들의 협력 관계를 그대로 재사용할 수 있다.
    
    ```java
     @Override
      public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        
        // 주문을 만들어서 반환한다.
        return new Order(memberId, itemName, itemPrice, discountPrice);
      } // 단일 원칙이 잘 지켜진 예
    ```
    
    ⇒ 할인에 대한 변경이 필요하면 할인 쪽만 고치면된다. 주문은 고칠 필요가 없다.
    
- **섹션3**
    
    **새로운 할인정책 개발과 문제점**
    
    - 정률할인으로 바꿀예정 → RatedDiscount 구현체만 만들어서 바꿔끼우면 됨.
    - Command + Shift + control을 사용해서 Test case를 만들 수 있다.
    
    ```java
    //then
        Assertions.assertThat(discount).isEqualTo(1000);
        // control + enter를 통해 static import를 하는 것이 좋다.
    ```
    
    ```java
      //private final DiscountPolicy discountPolicy = 
    						  new FixDiscountPolicy();
    						  
    	// 다형성을 활용한 할인정책변경
     private final DiscountPolicy discountPolicy = 
    							 new RateDiscountPolicy()DiscountPolicy();
    ```
    
    ⇒ 하지만 할인 정책을 변경하려면 **할인정책의 클라이언트**인 OrderServiceImp을 고쳐야한다.
    
    - 역할과 구현을 분리하고, 다형성을 활용했다
    - , OCP와 DIP를 준수했다? → x
        
        ```java
        public class OrderServiceImpl implements OrderService {
        	private final DiscountPolicy discountPolicy = 
        			new FixDiscountPolicy();
        	}
        ```
        
        → 추상(인터페이스: DiscountPolicy)뿐만 아니라 구체(구현: FixDiscountPolicy)클래스도 함께 의존하고 있다. 즉, **DIP 위반이다.**
        
    - 때문에 Fix에서 Rate로 구현체를 변경하기 위해서는 클라이언트(OrderServiceImpl)의 코드도 함께 변경해야 한다. **즉, OCP 위반이다.**
        - 일반차에서 전기차로 바꿨다고 운전자도 라이센스를 새로 발급받아야하는 상황.
    - How to solve? → DIP를 위반하지 않도록 인터페이스에만 의존하면 된다.
        
        ```java
           private final DiscountPolicy discountPolicy = 
        			new RateDiscountPolicy();
        => private  DiscountPolicy discountPolicy;
        //인터페이스에만 의존한다.
        ```
        
        - 하지만 구현체가 없으므로 Null point exception 발생
        - 누군가 클라이언트(OrderServiceImple)에 구현객체(DiscountPolicy)를 대신 생성하고 주입해야한다.
    
    **관심사의 분리(중요!!!)**
    
    - 방금 작성한 OCP, DIP를 위반한 코드는 예를 들면 줄리엣 역할을 맡은 사람이 로미오 배역을 맡을 사람을 직접 정하는 것과 같다.(OrderServiceImpl이 FixDiscountPolicy를 선택함)
    - 때문에 줄리엣 배역의 사람을 여러 책임을 가지게 된다.
    - 배역을 맡은 사람은 자신의 역할을 수행하는 것에만 집중해야한다.
    - 역할에 맡는 배우를 지정하는 등 다른 역할들은 별도의 “공연 기획자”가 해야한다.
    - 공연 기획자를 만들고 배우와의 책임을 확실히 분리해야한다.
    
    AppConfig
    
    - 애플리케이션의 전체 동작방식을 구현하기 위해, **구현객체를 생성**하고 **연결**하는 별도의 책임을 가지는 클래스를 만들어야한다.
        
        ```java
        public class AppConfig {
          //여기서 구현체를 생성해서 넣어준다.
          //생성자 주입
          public MemberService memberService() {
            return new MemberServiceImpl(new MemoryMemberRepository());
          }
        }
        ----------------------------------
        public class MemberServiceImpl implements MemberService{
          // MemoryMemberRepisitory 구현객체 설정 삭제
          private final MemberRepository memberRepository;
          
          //MemberRepository에 무엇이 들어갈지를 생성자를 통해서 정한다.
          //MemberServiceImpl에 MemoryMemberRepository에 관한 코드가 없다. 즉, 의존하지 않는다.
          public MemberServiceImpl(MemberRepository memberRepository){
          }
        }
        ```
        
    - AppConfig가 실제 동작에 필요한 구현 객체를 생성한다.
    - AppConfig는 생성한 인스턴스의 참조를 생성자를 통해서 주입(연결)해준다.
    - MemberServiceImpl의 생성자를 통해서 어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에 의해서만 결정된다.
    - AppConfig가 객체를 생성하고 연결하는 역할을 한다.
    
    클라이언트인 memberServiceImpl 입장에서 보면 의존관계를 외부에서 주입하는 것과 같아서 DI(의존관계 주입)이라고 한다.
    
    - @BeforeEach: 테스트실행하기 전마다 실행되는 것.
    
    AppConfig 리팩토링
    
    ```java
     public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
      }
    
      private static MemberRepository memberRepository() {
        return new MemoryMemberRepository();
      }
    
      public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
      }
    
      public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
      }
      //나중에 변경이 생길경우 return의 구현체만 바꿔주면 된다.
    ```
    
    - 이렇게 AppConfig를 설정하면 역할과 구현클래스가 한눈에 들어온다.
    - new MemoryRepository() 부분의 중복을 제거했다.
    
    새로운 구조와 할인 정책 적용
    
    - 할인 정책을 변경하기 위해서 FixDiscountPolicy()만 RateDiscountPolicy()로 변경하면 된다. 부품을 갈아끼우듯이.
    - AppConfig가 공연의 기획자 역할을 하는 것이다.
    
    SOLID 5가지 원칙의 적용
    
    - SRP: 한 클래스는 하나의 책임만 가져야한다.
        - 관심사분리 클라이언트 객체는 실행만 하고 나머지 책임은 AppConfig
    - DIP: 추상화에 의존해야함.
        - AppConfig가 FixDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성하고, 클라이언트 코드에 의존관계를 주입했다.
    - OCP: 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀있어야 한다.
        - 다형성을 사용하고 클라이언트가 DIP를 지킴.
        - AppConfig가 의존관계를 FixDiscountPolicy에서 RateDiscountPolicy로 변경해스 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 된다.
        - **소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다.**
            
            ⇒ 사용 영역의 변경은 닫혀있다의 뜻은 변경이 필요가 없다는 뜻이다.
            
    
    **IoC, DI, 그리고 컨테이너**
    
    - IoC: 제어의 역전
        - 기존 프로그램은 클라이언트 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.
        - AppConfig가 등장한 후 구현 객체는 자신의 로직 실행만 한다.
        - AppConfig가 프로그램에 대한 제어 흐름을 모두 가지고 있다.
        
        ⇒ 이와 같이 프로그램의 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 **제어의 역전(IoC)**라고한다.
        
        - 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크(ex.@Test, @BefoeEach…)
        - 내가 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리(ex.객체를 JSON으로 만들때)
    - 의존관계주입(DI)
        - 의존관계는 **정적인 클래스 의존관계**와, 실행시점에서 결정되는 **동적인 객체 의존관계**를 분리해서 생각해야한다.
        - **정적인 의존관계**는 어플리케이션을 실행하지 않아도 알 수 있다.
        - 구현클래스가 역할클래스를 의존한다고 한다. 클래스 다이어그램을 보면 확인할 수 있다.
        - 어플리케이션 실행 시점에서 실제 생성된 객체 인스턴스의 참조가 연결된 것이 동적인 **객체 인스턴스 의존관계**이다.
            - 실행 시점에서 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달하고 서버와 연결되는 것을 의존관계 주입이라고 한다.
            - 의존관계 주입을 사용하면 클라이언트 코드변경을 하지않고 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
            - **의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다!!!**
    - IoC 컨테이너, DI 컨테이너
        - AppConfig와 같이 객체를 생성하고 의존관계를 연결해주는 것을 **DI컨테이너**라고 한다.
    
    **스프링으로 전환하기**
    
    - 클래스 앞에 @Configuration을 붙이고, 각 메서드에 annotation으로 Bean을 추가하면 스프링 컨테이너에 등록이 된다.
    - Spring은 모든 것이 ApplicationContext에서 시작한다. 이것이 즉 스프링 컨테이너.(모든것을 관리해줌.)
        
        ```java
        ApplicationContext applicationContext = 
        			new AnnotationConfigApplicationContext(AppConfig.class);
        ```
        
        이 코드가 @Bean이 있는 것을 전부 스프링 컨테이너에 집어넣어서 관리해준다.
        
    - 기본적으로 Bean은 설정한 메서드 이름으로 등록이 된다.
        
        ```java
        MemberService memberService = 
        				applicationContext.getBean("memberService", MemberService.class);
        ```
        
        "memberService"이 찾는 이름이고, MemberService.class은 타입이다.
        
    - ApplicationContext를 스프링 컨테이너라고 한다.
    - 스프링 컨테이너가 객체를 생성하고 DI를 해준다.
    - 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정(구성)정보로 사용한다. @Bean이라고 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
    - 여기서 스프링 컨테이너에 등록된 객체가 스프링 빈이다. **즉, 스프링 빈은 객체이다.**
    - 스프링 빈은 메서드의 이름을 빈의 이름으로 사용한다.
    - 등록된 스프링 빈은 applicationContext.getBean 메서드를 이용해서 찾을 수 있다.